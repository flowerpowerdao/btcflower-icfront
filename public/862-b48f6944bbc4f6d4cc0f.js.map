{"version":3,"file":"862-b48f6944bbc4f6d4cc0f.js","mappings":"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","sources":["webpack://ic-agent-sw-cert-app/webpack/runtime/chunk loaded","webpack://ic-agent-sw-cert-app/webpack/runtime/startup chunk dependencies","webpack://ic-agent-sw-cert-app/./src/sw/validation.ts","webpack://ic-agent-sw-cert-app/./src/sw/http_request.ts","webpack://ic-agent-sw-cert-app/./src/sw/sw.ts","webpack://ic-agent-sw-cert-app/webpack/bootstrap","webpack://ic-agent-sw-cert-app/webpack/runtime/amd options","webpack://ic-agent-sw-cert-app/webpack/runtime/define property getters","webpack://ic-agent-sw-cert-app/webpack/runtime/ensure chunk","webpack://ic-agent-sw-cert-app/webpack/runtime/get javascript chunk filename","webpack://ic-agent-sw-cert-app/webpack/runtime/global","webpack://ic-agent-sw-cert-app/webpack/runtime/hasOwnProperty shorthand","webpack://ic-agent-sw-cert-app/webpack/runtime/make namespace object","webpack://ic-agent-sw-cert-app/webpack/runtime/publicPath","webpack://ic-agent-sw-cert-app/webpack/runtime/importScripts chunk loading","webpack://ic-agent-sw-cert-app/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(450).then(next);\n};","import { Cbor as cbor, Certificate, lookup_path, reconstruct, } from '@dfinity/agent';\n/**\n * Validate whether a body is properly certified.\n * @param canisterId The canister ID that provided the resource.\n * @param path The path of the resource requested to be validated (including the prefix `/`).\n * @param body An asset body, as it appears on the HTTP response (not decoded)\n * @param certificate The certificate to validate the .\n * @param tree The merkle tree returned by the canister.\n * @param agent A JavaScript agent that can validate certificates.\n * @param shouldFetchRootKey Whether should fetch the root key if it isn't available.\n * @returns True if the body is valid.\n */\nexport async function validateBody(canisterId, path, body, certificate, tree, agent, shouldFetchRootKey = false) {\n    const cert = new Certificate({ certificate: new Uint8Array(certificate) }, agent);\n    // If we're running locally, update the key manually.\n    if (shouldFetchRootKey) {\n        await agent.fetchRootKey();\n    }\n    // Make sure the certificate is valid.\n    if (!(await cert.verify())) {\n        return false;\n    }\n    const hashTree = cbor.decode(new Uint8Array(tree));\n    const reconstructed = await reconstruct(hashTree);\n    const witness = cert.lookup(['canister', canisterId.toUint8Array(), 'certified_data']);\n    if (!witness) {\n        throw new Error('Could not find certified data for this canister in the certificate.');\n    }\n    // First validate that the Tree is as good as the certification.\n    if (!equal(witness, reconstructed)) {\n        console.error('Witness != Tree passed in ic-certification');\n        return false;\n    }\n    // Next, calculate the SHA of the content.\n    const sha = await crypto.subtle.digest('SHA-256', body);\n    let treeSha = lookup_path(['http_assets', path], hashTree);\n    if (!treeSha) {\n        // Allow fallback to `index.html`.\n        treeSha = lookup_path(['http_assets', '/index.html'], hashTree);\n    }\n    if (!treeSha) {\n        // The tree returned in the certification header is wrong. Return false.\n        // We don't throw here, just invalidate the request.\n        console.error(`Invalid Tree in the header. Does not contain path ${JSON.stringify(path)}`);\n        return false;\n    }\n    return !!treeSha && equal(sha, treeSha);\n}\nfunction equal(buf1, buf2) {\n    if (buf1.byteLength !== buf2.byteLength) {\n        return false;\n    }\n    const a1 = new Uint8Array(buf1);\n    const a2 = new Uint8Array(buf2);\n    for (let i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","/**\n * Implement the HttpRequest to Canisters Proposal.\n *\n * TODO: Add support for streaming.\n */\nimport { Actor, HttpAgent } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { validateBody } from './validation';\nimport * as base64Arraybuffer from 'base64-arraybuffer';\nimport * as pako from 'pako';\nconst CANISTER_ID = \"oartq-4qaaa-aaaae-qaa6q-cai\";\nconst MY_DOMAIN = \"icfront-letmejustputthishere.vercel.app\";\nconst canisterIdlFactory = ({ IDL }) => {\n    const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);\n    const HttpRequest = IDL.Record({\n        method: IDL.Text,\n        url: IDL.Text,\n        headers: IDL.Vec(HeaderField),\n        body: IDL.Vec(IDL.Nat8),\n    });\n    const HttpResponse = IDL.Record({\n        status_code: IDL.Nat16,\n        headers: IDL.Vec(HeaderField),\n        body: IDL.Vec(IDL.Nat8),\n    });\n    return IDL.Service({\n        http_request: IDL.Func([HttpRequest], [HttpResponse], ['query']),\n    });\n};\n/**\n * Decode a body (ie. deflate or gunzip it) based on its content-encoding.\n * @param body The body to decode.\n * @param encoding Its content-encoding associated header.\n */\nfunction decodeBody(body, encoding) {\n    switch (encoding) {\n        case 'identity':\n        case '':\n            return body;\n        case 'gzip':\n            return pako.ungzip(body);\n        case 'deflate':\n            return pako.inflate(body);\n        default:\n            throw new Error(`Unsupported encoding: \"${encoding}\"`);\n    }\n}\n/**\n * Box a request, send it to the canister, and handle its response, creating a Response\n * object.\n * @param request The request received from the browser.\n * @returns The response to send to the browser.\n * @throws If an internal error happens.\n */\nexport async function handleRequest(request) {\n    const url = new URL(request.url);\n    /**\n     * If this is not for us, pass it on.\n     */\n    if (!url.hostname.endsWith(MY_DOMAIN)) {\n        return await fetch(request);\n    }\n    /**\n     * We try to do an HTTP Request query.\n     */\n    const canisterId = Principal.fromText(CANISTER_ID);\n    try {\n        const replicaUrl = new URL(\"https://ic0.app\");\n        const agent = new HttpAgent({ host: replicaUrl.toString() });\n        const actor = Actor.createActor(canisterIdlFactory, {\n            agent,\n            canisterId: canisterId,\n        });\n        const requestHeaders = [];\n        request.headers.forEach((value, key) => requestHeaders.push([key, value]));\n        // If the accept encoding isn't given, add it because we want to save bandwidth.\n        if (!request.headers.has('Accept-Encoding')) {\n            requestHeaders.push(['Accept-Encoding', 'gzip, deflate, identity']);\n        }\n        const httpRequest = {\n            method: request.method,\n            url: url.pathname + url.search,\n            headers: requestHeaders,\n            body: [...new Uint8Array(await request.arrayBuffer())],\n        };\n        const httpResponse = await actor.http_request(httpRequest);\n        const headers = new Headers();\n        let certificate;\n        let tree;\n        let encoding = '';\n        for (const [key, value] of httpResponse.headers) {\n            switch (key.trim().toLowerCase()) {\n                case 'ic-certificate':\n                    {\n                        const fields = value.split(/,/);\n                        for (const f of fields) {\n                            const [_0, name, b64Value] = [...f.match(/^(.*)=:(.*):$/)].map(x => x.trim());\n                            const value = base64Arraybuffer.decode(b64Value);\n                            if (name === 'certificate') {\n                                certificate = value;\n                            }\n                            else if (name === 'tree') {\n                                tree = value;\n                            }\n                        }\n                    }\n                    continue;\n                case 'content-encoding':\n                    encoding = value.trim();\n                    break;\n            }\n            headers.append(key, value);\n        }\n        const body = new Uint8Array(httpResponse.body);\n        const identity = decodeBody(body, encoding);\n        let bodyValid = false;\n        if (certificate && tree) {\n            // Try to validate the body as is.\n            bodyValid = await validateBody(canisterId, url.pathname, body.buffer, certificate, tree, agent, false);\n            if (!bodyValid) {\n                // If that didn't work, try to validate its identity version. This is for\n                // backward compatibility.\n                bodyValid = await validateBody(canisterId, url.pathname, identity.buffer, certificate, tree, agent, false);\n            }\n        }\n        if (bodyValid) {\n            return new Response(identity.buffer, {\n                status: httpResponse.status_code,\n                headers,\n            });\n        }\n        else {\n            console.error('BODY DOES NOT PASS VERIFICATION');\n            return new Response('Body does not pass verification', { status: 500 });\n        }\n    }\n    catch (e) {\n        console.error('Failed to fetch response:', e);\n        return new Response(`Failed to fetch response: ${e.toString()}`, { status: 500 });\n    }\n    console.error(`URL ${JSON.stringify(url.toString())} did not resolve to a canister ID.`);\n    return new Response('Could not find the canister ID.', { status: 404 });\n}\n","import { handleRequest } from './http_request';\nconst DEBUG = true;\n// Always install updated SW immediately\nself.addEventListener('install', () => {\n    self.skipWaiting();\n});\n// Intercept and proxy all fetch requests made by the browser or DOM on this scope.\nself.addEventListener('fetch', (event) => {\n    try {\n        const response = handleRequest(event.request);\n        event.respondWith(response);\n    }\n    catch (e) {\n        let error_message = String(e);\n        console.error(error_message);\n        if (DEBUG) {\n            return event.respondWith(new Response(error_message, {\n                status: 501,\n            }));\n        }\n        event.respondWith(new Response('Internal Error', { status: 502 }));\n    }\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [450], () => (__webpack_require__(862)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdO = {};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \"-\" + \"e9fcceaf1ec6c07574b1\" + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t862: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkic_agent_sw_cert_app\"] = self[\"webpackChunkic_agent_sw_cert_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","async","validateBody","canisterId","path","body","certificate","tree","agent","shouldFetchRootKey","cert","Uint8Array","fetchRootKey","verify","hashTree","reconstructed","witness","lookup","toUint8Array","Error","equal","console","error","sha","crypto","subtle","digest","treeSha","JSON","stringify","buf1","buf2","byteLength","a1","a2","i","length","canisterIdlFactory","IDL","HeaderField","Tuple","Text","HttpRequest","Record","method","url","headers","Vec","Nat8","HttpResponse","status_code","Nat16","Service","http_request","Func","self","addEventListener","skipWaiting","event","response","request","URL","hostname","endsWith","fetch","replicaUrl","host","toString","actor","requestHeaders","forEach","value","key","push","has","httpRequest","pathname","search","arrayBuffer","httpResponse","Headers","encoding","trim","toLowerCase","fields","split","f","_0","name","b64Value","match","map","x","append","identity","decodeBody","bodyValid","buffer","Response","status","e","handleRequest","respondWith","error_message","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","amdO","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","splice","r","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","reduce","promises","u","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","data","moreModules","runtime","pop","then"],"sourceRoot":""}